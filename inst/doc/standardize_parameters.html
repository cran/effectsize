<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
@font-face {
font-family: octicons-link;
src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}
body {
-webkit-text-size-adjust: 100%;
text-size-adjust: 100%;
color: #333;
font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
font-size: 16px;
line-height: 1.6;
word-wrap: break-word;
}
a {
background-color: transparent;
}
a:active,
a:hover {
outline: 0;
}
strong {
font-weight: bold;
}
h1 {
font-size: 2em;
margin: 0.67em 0;
}
img {
border: 0;
}
hr {
box-sizing: content-box;
height: 0;
}
pre {
overflow: auto;
}
code,
kbd,
pre {
font-family: monospace, monospace;
font-size: 1em;
}
input {
color: inherit;
font: inherit;
margin: 0;
}
html input[disabled] {
cursor: default;
}
input {
line-height: normal;
}
input[type="checkbox"] {
box-sizing: border-box;
padding: 0;
}
table {
border-collapse: collapse;
border-spacing: 0;
}
td,
th {
padding: 0;
}
* {
box-sizing: border-box;
}
input {
font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}
a {
color: #4078c0;
text-decoration: none;
}
a:hover,
a:active {
text-decoration: underline;
}
hr {
height: 0;
margin: 15px 0;
overflow: hidden;
background: transparent;
border: 0;
border-bottom: 1px solid #ddd;
}
hr:before {
display: table;
content: "";
}
hr:after {
display: table;
clear: both;
content: "";
}
h1,
h2,
h3,
h4,
h5,
h6 {
margin-top: 15px;
margin-bottom: 15px;
line-height: 1.1;
}
h1 {
font-size: 30px;
}
h2 {
font-size: 21px;
}
h3 {
font-size: 16px;
}
h4 {
font-size: 14px;
}
h5 {
font-size: 12px;
}
h6 {
font-size: 11px;
}
blockquote {
margin: 0;
}
ul,
ol {
padding: 0;
margin-top: 0;
margin-bottom: 0;
}
ol ol,
ul ol {
list-style-type: lower-roman;
}
ul ul ol,
ul ol ol,
ol ul ol,
ol ol ol {
list-style-type: lower-alpha;
}
dd {
margin-left: 0;
}
code {
font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
font-size: 12px;
}
pre {
margin-top: 0;
margin-bottom: 0;
font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}
.select::-ms-expand {
opacity: 0;
}
.octicon {
font: normal normal normal 16px/1 octicons-link;
display: inline-block;
text-decoration: none;
text-rendering: auto;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
}
.octicon-link:before {
content: '\f05c';
}
.markdown-body:before {
display: table;
content: "";
}
.markdown-body:after {
display: table;
clear: both;
content: "";
}
.markdown-body>*:first-child {
margin-top: 0 !important;
}
.markdown-body>*:last-child {
margin-bottom: 0 !important;
}
a:not([href]) {
color: inherit;
text-decoration: none;
}
.anchor {
display: inline-block;
padding-right: 2px;
margin-left: -18px;
}
.anchor:focus {
outline: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
margin-top: 1em;
margin-bottom: 16px;
font-weight: bold;
line-height: 1.4;
}
h1 .octicon-link,
h2 .octicon-link,
h3 .octicon-link,
h4 .octicon-link,
h5 .octicon-link,
h6 .octicon-link {
color: #000;
vertical-align: middle;
visibility: hidden;
}
h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
text-decoration: none;
}
h1:hover .anchor .octicon-link,
h2:hover .anchor .octicon-link,
h3:hover .anchor .octicon-link,
h4:hover .anchor .octicon-link,
h5:hover .anchor .octicon-link,
h6:hover .anchor .octicon-link {
visibility: visible;
}
h1 {
padding-bottom: 0.3em;
font-size: 2.25em;
line-height: 1.2;
border-bottom: 1px solid #eee;
}
h1 .anchor {
line-height: 1;
}
h2 {
padding-bottom: 0.3em;
font-size: 1.75em;
line-height: 1.225;
border-bottom: 1px solid #eee;
}
h2 .anchor {
line-height: 1;
}
h3 {
font-size: 1.5em;
line-height: 1.43;
}
h3 .anchor {
line-height: 1.2;
}
h4 {
font-size: 1.25em;
}
h4 .anchor {
line-height: 1.2;
}
h5 {
font-size: 1em;
}
h5 .anchor {
line-height: 1.1;
}
h6 {
font-size: 1em;
color: #777;
}
h6 .anchor {
line-height: 1.1;
}
p,
blockquote,
ul,
ol,
dl,
table,
pre {
margin-top: 0;
margin-bottom: 16px;
}
hr {
height: 4px;
padding: 0;
margin: 16px 0;
background-color: #e7e7e7;
border: 0 none;
}
ul,
ol {
padding-left: 2em;
}
ul ul,
ul ol,
ol ol,
ol ul {
margin-top: 0;
margin-bottom: 0;
}
li>p {
margin-top: 16px;
}
dl {
padding: 0;
}
dl dt {
padding: 0;
margin-top: 16px;
font-size: 1em;
font-style: italic;
font-weight: bold;
}
dl dd {
padding: 0 16px;
margin-bottom: 16px;
}
blockquote {
padding: 0 15px;
color: #777;
border-left: 4px solid #ddd;
}
blockquote>:first-child {
margin-top: 0;
}
blockquote>:last-child {
margin-bottom: 0;
}
table {
display: block;
width: 100%;
overflow: auto;
word-break: normal;
word-break: keep-all;
}
table th {
font-weight: bold;
}
table th,
table td {
padding: 6px 13px;
border: 1px solid #ddd;
}
table tr {
background-color: #fff;
border-top: 1px solid #ccc;
}
table tr:nth-child(2n) {
background-color: #f8f8f8;
}
img {
max-width: 100%;
box-sizing: content-box;
background-color: #fff;
}
code {
padding: 0;
padding-top: 0.2em;
padding-bottom: 0.2em;
margin: 0;
font-size: 85%;
background-color: rgba(0,0,0,0.04);
border-radius: 3px;
}
code:before,
code:after {
letter-spacing: -0.2em;
content: "\00a0";
}
pre>code {
padding: 0;
margin: 0;
font-size: 100%;
word-break: normal;
white-space: pre;
background: transparent;
border: 0;
}
.highlight {
margin-bottom: 16px;
}
.highlight pre,
pre {
padding: 16px;
overflow: auto;
font-size: 85%;
line-height: 1.45;
background-color: #f7f7f7;
border-radius: 3px;
}
.highlight pre {
margin-bottom: 0;
word-break: normal;
}
pre {
word-wrap: normal;
}
pre code {
display: inline;
max-width: initial;
padding: 0;
margin: 0;
overflow: initial;
line-height: inherit;
word-wrap: normal;
background-color: transparent;
border: 0;
}
pre code:before,
pre code:after {
content: normal;
}
kbd {
display: inline-block;
padding: 3px 5px;
font-size: 11px;
line-height: 10px;
color: #555;
vertical-align: middle;
background-color: #fcfcfc;
border: solid 1px #ccc;
border-bottom-color: #bbb;
border-radius: 3px;
box-shadow: inset 0 -1px 0 #bbb;
}
.pl-c {
color: #969896;
}
.pl-c1,
.pl-s .pl-v {
color: #0086b3;
}
.pl-e,
.pl-en {
color: #795da3;
}
.pl-s .pl-s1,
.pl-smi {
color: #333;
}
.pl-ent {
color: #63a35c;
}
.pl-k {
color: #a71d5d;
}
.pl-pds,
.pl-s,
.pl-s .pl-pse .pl-s1,
.pl-sr,
.pl-sr .pl-cce,
.pl-sr .pl-sra,
.pl-sr .pl-sre {
color: #183691;
}
.pl-v {
color: #ed6a43;
}
.pl-id {
color: #b52a1d;
}
.pl-ii {
background-color: #b52a1d;
color: #f8f8f8;
}
.pl-sr .pl-cce {
color: #63a35c;
font-weight: bold;
}
.pl-ml {
color: #693a17;
}
.pl-mh,
.pl-mh .pl-en,
.pl-ms {
color: #1d3e81;
font-weight: bold;
}
.pl-mq {
color: #008080;
}
.pl-mi {
color: #333;
font-style: italic;
}
.pl-mb {
color: #333;
font-weight: bold;
}
.pl-md {
background-color: #ffecec;
color: #bd2c00;
}
.pl-mi1 {
background-color: #eaffea;
color: #55a532;
}
.pl-mdr {
color: #795da3;
font-weight: bold;
}
.pl-mo {
color: #1d3e81;
}
kbd {
display: inline-block;
padding: 3px 5px;
font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
line-height: 10px;
color: #555;
vertical-align: middle;
background-color: #fcfcfc;
border: solid 1px #ccc;
border-bottom-color: #bbb;
border-radius: 3px;
box-shadow: inset 0 -1px 0 #bbb;
}
.task-list-item {
list-style-type: none;
}
.task-list-item+.task-list-item {
margin-top: 3px;
}
.task-list-item input {
margin: 0 0.35em 0.25em -1.6em;
vertical-align: middle;
}
:checked+.radio-label {
z-index: 1;
position: relative;
border-color: #4078c0;
}
.sourceLine {
display: inline-block;
}
code .kw { color: #000000; }
code .dt { color: #ed6a43; }
code .dv { color: #009999; }
code .bn { color: #009999; }
code .fl { color: #009999; }
code .ch { color: #009999; }
code .st { color: #183691; }
code .co { color: #969896; }
code .ot { color: #0086b3; }
code .al { color: #a61717; }
code .fu { color: #63a35c; }
code .er { color: #a61717; background-color: #e3d2d2; }
code .wa { color: #000000; }
code .cn { color: #008080; }
code .sc { color: #008080; }
code .vs { color: #183691; }
code .ss { color: #183691; }
code .im { color: #000000; }
code .va {color: #008080; }
code .cf { color: #000000; }
code .op { color: #000000; }
code .bu { color: #000000; }
code .ex { color: #000000; }
code .pp { color: #999999; }
code .at { color: #008080; }
code .do { color: #969896; }
code .an { color: #008080; }
code .cv { color: #008080; }
code .in { color: #008080; }
</style>
<style>
body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
  padding-top: 0px;
}
</style>

</head>

<body>

<h1 id="parameter-and-model-standardization">Parameter and Model Standardization</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#standardizing-parameters-of-simple-models">Standardizing Parameters of Simple Models</a>
<ul>
<li><a href="#standardized-associations">Standardized Associations</a></li>
<li><a href="#standardized-differences">Standardized Differences</a></li>
</ul></li>
<li><a href="#standardizing-parameters-of-linear-models">Standardizing Parameters of Linear Models</a>
<ul>
<li><a href="#standardized-slopes-are-not-always-correlations">Standardized Slopes are Not (Always) Correlations</a></li>
<li><a href="#methods-of-standardizing-parameters">Methods of Standardizing Parameters</a>
<ul>
<li><a href="#refit-re-fitting-the-model-with-standardized-data"><strong><code>&quot;refit&quot;</code></strong>: Re-fitting the model with standardized data</a></li>
<li><a href="#posthoc-refit-without-refitting"><strong><code>&quot;posthoc&quot;</code></strong>: Refit without refitting</a></li>
<li><a href="#smart-standardization-of-models-parameters-with-adjustment-reconnaissance-and-transformation"><strong><code>&quot;smart&quot;</code></strong>: Standardization of Model’s parameters with Adjustment, Reconnaissance and Transformation</a></li>
<li><a href="#basic-raw-scaling-of-the-model-frame"><strong><code>&quot;basic&quot;</code></strong>: Raw scaling of the model frame</a></li>
</ul></li>
<li><a href="#standardizing-parameters-in-mixed-models">Standardizing Parameters In Mixed Models</a></li>
<li><a href="#standardizing-parameters-in-generalized-linear-models">Standardizing Parameters In Generalized Linear Models</a></li>
</ul></li>
<li><a href="#cohens-f">Cohen’s <em>f</em></a></li>
<li><a href="#references">References</a></li>
</ul>
<!-- centering and interactions! -->

<h1 id="introduction">Introduction</h1>
<p>Standardizing parameters (<em>i.e.</em>, coefficients) can allow for their comparison within and between models, variables and studies. Moreover, as it returns coefficients expressed in terms of <strong>change of variance</strong> (for instance, coefficients expressed in terms of SD of the response variable), it can allow for the usage of <a href="https://easystats.github.io/effectsize/articles/interpret.html">effect size interpretation guidelines</a>, such as Cohen’s (1988) famous rules of thumb.</p>
<p>However, standardizing a model’s parameters should <em>not</em> be automatically and mindlessly done: for some research fields, particular variables or types of studies (<em>e.g.</em>, replications), it sometimes makes more sense to keep, use and interpret the original parameters, especially if they are well known or easily understood.</p>
<p>Critically, <strong>parameters standardization is not a trivial process</strong>. Different techniques exist, that can lead to drastically different results. Thus, it is critical that the standardization method is explicitly documented and detailed.</p>
<!-- **`parameters` include different techniques of parameters standardization**, described below [@bring1994standardize;@menard2004six;@gelman2008scaling;@schielzeth2010simple;@menard2011standards]. -->

<h1 id="standardizing-parameters-of-simple-models">Standardizing Parameters of Simple Models</h1>
<h2 id="standardized-associations">Standardized Associations</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(effectsize)</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>m &lt;-<span class="st"> </span><span class="kw">lm</span>(Sepal.Length <span class="op">~</span><span class="st"> </span>Petal.Length, <span class="dt">data =</span> iris)</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">standardize_parameters</span>(m)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |          -5.03e-16 | [-0.08, 0.08]
&gt; Petal.Length |               0.87 | [ 0.79, 0.95]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p>Standardizing the coefficient of this <em>simple</em> linear regression gives a value of <code>0.87</code>, but did you know that for a simple regression this is actually the <strong>same as a correlation</strong>? Thus, you can eventually apply some (<em>in</em>)famous interpretation guidelines (e.g., Cohen’s rules of thumb).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">library</span>(parameters)</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>r &lt;-<span class="st"> </span><span class="kw">cor.test</span>(iris<span class="op">$</span>Sepal.Length, iris<span class="op">$</span>Petal.Length)</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">model_parameters</span>(r)</span></code></pre></div>
<pre><code>&gt; Parameter1        |        Parameter2 |    r | t(148) |      p |       95% CI |  Method
&gt; ---------------------------------------------------------------------------------------
&gt; iris$Sepal.Length | iris$Petal.Length | 0.87 |  21.65 | &lt; .001 | [0.83, 0.91] | Pearson
</code></pre>
<h2 id="standardized-differences">Standardized Differences</h2>
<p>How does it work in the case of differences, when <strong>factors</strong> are entered and differences between a given level and a reference level? You might have heard that it is similar to a <strong>Cohen’s <em>d</em></strong>. Well, let’s see.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Select portion of data containing the two levels of interest</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>mtcars<span class="op">$</span>am &lt;-<span class="st"> </span><span class="kw">factor</span>(mtcars<span class="op">$</span>am, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Manual&quot;</span>, <span class="st">&quot;Automatic&quot;</span>))</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>m &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>am, <span class="dt">data =</span> mtcars)</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">standardize_parameters</span>(m)</span></code></pre></div>
<pre><code>&gt; Parameter   | Coefficient (std.) |         95% CI
&gt; -------------------------------------------------
&gt; (Intercept) |              -0.49 | [-0.87, -0.11]
&gt; amAutomatic |               1.20 | [ 0.60,  1.80]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p>This linear model suggests that the <em>standardized</em> difference between <em>Manual</em> (the reference level - the model’s intercept) and <em>Automatic</em> is of 1.20 standard deviation of <code>mpg</code> (because the response variable was standardized, right?). Let’s compute the <strong>Cohen’s <em>d</em></strong> between these two levels:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">cohens_d</span>(mpg <span class="op">~</span><span class="st"> </span>am, <span class="dt">data =</span> mtcars) </span></code></pre></div>
<pre><code>&gt; Cohen&#39;s d |         95% CI
&gt; --------------------------
&gt;     -1.48 | [-2.27, -0.67]
</code></pre>
<p><em><strong>It is larger!</strong></em> Why? How? Both differences should be expressed in units of SD! But which SDs? Different SDs!</p>
<p>When looking at the difference between groups as a <strong>slope</strong>, the standardized parameter is the difference between the means in (SD_{mpg}). That is, the <em>slope</em> between <code>Manual</code> and <code>Automatic</code> is a change of 1.20 (SD_{mpg})s.</p>
<p>However, when looking a the difference as a <strong>distance between two populations</strong>, Cohen’s d is the distance between the means in units of <a href="https://easystats.github.io/effectsize/reference/sd_pooled.html"><strong>pooled SDs</strong></a>. That is, the <em>distance</em> between <code>Manual</code> and <code>Automatic</code> is of 1.48 SDs of <em>each of the groups</em> (here assumed to be equal).</p>
<p>In this simple model, the pooled SD is the residual SD, so we can also estimate Cohen’s <em>d</em> as:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">coef</span>(m)[<span class="dv">2</span>] <span class="op">/</span><span class="st"> </span><span class="kw">sigma</span>(m)</span></code></pre></div>
<pre><code>&gt; amAutomatic 
&gt;         1.5
</code></pre>
<p>And we can also get an approximation of Cohen’s <em>d</em> by converting the (t)-statistic from the regression model via <code>t_to_d()</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>parameters<span class="op">::</span><span class="kw">model_parameters</span>(m)</span></code></pre></div>
<pre><code>&gt; Parameter      | Coefficient |   SE |         95% CI | t(30) |      p
&gt; ---------------------------------------------------------------------
&gt; (Intercept)    |       17.15 | 1.12 | [14.85, 19.44] | 15.25 | &lt; .001
&gt; am [Automatic] |        7.24 | 1.76 | [ 3.64, 10.85] |  4.11 | &lt; .001
</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">t_to_d</span>(<span class="fl">4.11</span>, <span class="dt">df_error =</span> <span class="dv">30</span>)</span></code></pre></div>
<pre><code>&gt;    d |       95% CI
&gt; -------------------
&gt; 1.50 | [0.68, 2.30]
</code></pre>
<p>It is also interesting to note that using the <code>smart</code> method (explained in detail below) when standardizing parameters will give you indices equivalent to <strong>Glass’ <em>delta</em></strong>, which is a standardized difference expressed in terms of SD of the reference group.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>m &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>am, <span class="dt">data =</span> mtcars)</span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">standardize_parameters</span>(m, <span class="dt">method =</span> <span class="st">&quot;smart&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter   | Coefficient (std.) |       95% CI
&gt; -----------------------------------------------
&gt; (Intercept) |               0.00 | [0.00, 0.00]
&gt; amAutomatic |               1.17 | [0.59, 1.76]
&gt; 
&gt; # Standardization method: Smart
</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">glass_delta</span>(mpg <span class="op">~</span><span class="st"> </span>am, <span class="dt">data =</span> mtcars)</span></code></pre></div>
<pre><code>&gt; Glass&#39; delta |         95% CI
&gt; -----------------------------
&gt;        -1.17 | [-1.93, -0.40]
</code></pre>
<p><em><strong>… So note that some standardized differences are different than others! :)</strong></em></p>
<h1 id="standardizing-parameters-of-linear-models">Standardizing Parameters of Linear Models</h1>
<p>As mentioned above, standardization of parameters can also be used to compare among parameters within the same model. Essentially, what prevents us from normally being able to compare among different parameters is that their underlying variables are on different scales.[^But also as noted above, this is not always an issue. For example, when the variables scale is important for the interpretation of results, standardization might in fact hinder interpretation!]</p>
<p>For example, in the following example, we use a liner regression model to predict a worker’s salary (in Shmekels) from their age (years), seniority (years), overtime (<code>xtra_hours</code>) and how many compliments they give their boss (<code>n_comps</code>).</p>
<p>Let us explore the different parameter standardization methods provided by <code>effectsize</code>.</p>
<h2 id="standardized-slopes-are-not-always-correlations">Standardized Slopes are Not (Always) Correlations</h2>
<p>We saw that in simple linear models, the standardized slope is equal to the correlation between the outcome and predictor - does this hold for <strong>multiple regression</strong> as well? As in each effect in a regression model is “adjusted” for the other ones, we might expect coefficients to be somewhat alike to <strong>partial correlations</strong>. Let’s first start by computing the partial correlation between numeric predictors and the outcome.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">data</span>(<span class="st">&quot;hardlyworking&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;effectsize&quot;</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">head</span>(hardlyworking)</span></code></pre></div>
<pre><code>&gt;   salary xtra_hours n_comps age seniority
&gt; 1  19745        4.2       1  32         3
&gt; 2  11302        1.6       0  34         3
&gt; 3  20636        1.2       3  33         5
&gt; 4  23047        7.2       1  35         3
&gt; 5  27342       11.3       0  33         4
&gt; 6  25657        3.6       2  30         5
</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>correlation<span class="op">::</span><span class="kw">correlation</span>(<span class="dt">data =</span> hardlyworking[,<span class="dv">1</span>], <span class="co"># the outcome of salary</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>                         <span class="dt">data2 =</span> hardlyworking[,<span class="op">-</span><span class="dv">1</span>], <span class="co"># the predictors</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>                         <span class="dt">partial =</span> <span class="ot">TRUE</span>) <span class="co"># get partial correlations</span></span></code></pre></div>
<pre><code>&gt; Parameter1 | Parameter2 |    r |       95% CI | t(498) |      p |  Method | n_Obs
&gt; ---------------------------------------------------------------------------------
&gt; data       | xtra_hours | 0.87 | [0.85, 0.89] |  39.79 | &lt; .001 | Pearson |   500
&gt; data       |    n_comps | 0.71 | [0.66, 0.75] |  22.40 | &lt; .001 | Pearson |   500
&gt; data       |        age | 0.09 | [0.01, 0.18] |   2.09 | 0.221  | Pearson |   500
&gt; data       |  seniority | 0.19 | [0.10, 0.27] |   4.30 | &lt; .001 | Pearson |   500
</code></pre>
<p>Let’s compare these to the standardized slopes:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>mod &lt;-<span class="st"> </span><span class="kw">lm</span>(salary <span class="op">~</span><span class="st"> </span>xtra_hours <span class="op">+</span><span class="st"> </span>n_comps <span class="op">+</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>seniority,</span>
<span id="cb23-2"><a href="#cb23-2"></a>          <span class="dt">data =</span> hardlyworking)</span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="kw">standardize_parameters</span>(mod)</span></code></pre></div>
<pre><code>&gt; Parameter   | Coefficient (std.) |        95% CI
&gt; ------------------------------------------------
&gt; (Intercept) |          -4.52e-17 | [-0.03, 0.03]
&gt; xtra_hours  |               0.77 | [ 0.73, 0.81]
&gt; n_comps     |               0.39 | [ 0.36, 0.42]
&gt; age         |               0.04 | [ 0.00, 0.07]
&gt; seniority   |               0.08 | [ 0.04, 0.12]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p>They are quite different! It seems then that <em><strong>standardized slopes in multiple linear regressions are not the same a correlations or partial correlations</strong></em> :(</p>
<p>However, not all hope is lost yet - we can still try and recover the partial correlations from our model, in another way: by converting the <em>t</em>-statistics (and their degrees of freedom, <em>df</em>) into a partial correlation coefficient <em>r</em>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>params &lt;-<span class="st"> </span><span class="kw">model_parameters</span>(mod)</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">t_to_r</span>(params<span class="op">$</span>t[<span class="op">-</span><span class="dv">1</span>], <span class="dt">df_error =</span> params<span class="op">$</span>df_error[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div>
<pre><code>&gt;    r |       95% CI
&gt; -------------------
&gt; 0.87 | [0.85, 0.89]
&gt; 0.71 | [0.67, 0.74]
&gt; 0.09 | [0.01, 0.18]
&gt; 0.19 | [0.10, 0.27]
</code></pre>
<p>Wow, the retrieved correlations coefficients from the regression model are <strong>exactly</strong> the same as the partial correlations we estimated above! So these “<em>r</em>” effect sizes can also be used.</p>
<h2 id="methods-of-standardizing-parameters">Methods of Standardizing Parameters</h2>
<p>Let’s convert <code>age</code> into a 3-level factor:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>hardlyworking<span class="op">$</span>age_g &lt;-<span class="st"> </span><span class="kw">cut</span>(hardlyworking<span class="op">$</span>age,</span>
<span id="cb27-2"><a href="#cb27-2"></a>                           <span class="dt">breaks =</span> <span class="kw">c</span>(<span class="dv">25</span>,<span class="dv">30</span>,<span class="dv">35</span>,<span class="dv">45</span>))</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a>mod &lt;-<span class="st"> </span><span class="kw">lm</span>(salary <span class="op">~</span><span class="st"> </span>xtra_hours <span class="op">+</span><span class="st"> </span>n_comps <span class="op">+</span><span class="st"> </span>age_g <span class="op">+</span><span class="st"> </span>seniority,</span>
<span id="cb27-5"><a href="#cb27-5"></a>          <span class="dt">data =</span> hardlyworking)</span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="kw">model_parameters</span>(mod)</span></code></pre></div>
<pre><code>&gt; Parameter       | Coefficient |     SE |              95% CI | t(494) |      p
&gt; ------------------------------------------------------------------------------
&gt; (Intercept)     |     9805.17 | 446.73 | [8927.44, 10682.89] |  21.95 | &lt; .001
&gt; xtra_hours      |     1221.39 |  30.72 | [1161.03,  1281.75] |  39.76 | &lt; .001
&gt; n_comps         |     2944.95 | 131.12 | [2687.32,  3202.57] |  22.46 | &lt; .001
&gt; age_g [(30,35]] |      393.40 | 241.02 | [ -80.16,   866.96] |   1.63 | 0.103 
&gt; age_g [(35,45]] |      596.31 | 427.75 | [-244.12,  1436.75] |   1.39 | 0.164 
&gt; seniority       |      443.92 | 102.38 | [ 242.77,   645.08] |   4.34 | &lt; .001
</code></pre>
<p>It seems like the best or most important predictor is <code>n_comps</code> as it has the coefficient. However, it is hard to compare among predictors, as they are on different scales. To address this issue, we must have all the predictors on the same scale - usually in the arbitrary unit of <em>standard deviations</em>.</p>
<h3 id="refit-re-fitting-the-model-with-standardized-data"><strong><code>&quot;refit&quot;</code></strong>: Re-fitting the model with standardized data</h3>
<p><strong>This method is based on a complete model re-fit with a standardized version of data</strong>. Hence, this method is equal to standardizing the variables <em>before</em> fitting the model. It is the “purest” and the most accurate (Neter, Wasserman, and Kutner 1989), but it is also the most computationally costly and long (especially for heavy models such as Bayesian models, or complex mixed models). This method is particularly recommended for models that include interactions or transformations (e.g., exponentiation, log, polynomial or spline terms).</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |              -0.05 | [-0.11, 0.02]
&gt; xtra_hours   |               0.77 | [ 0.73, 0.81]
&gt; n_comps      |               0.39 | [ 0.36, 0.43]
&gt; age_g(30,35] |               0.06 | [-0.01, 0.14]
&gt; age_g(35,45] |               0.10 | [-0.04, 0.23]
&gt; seniority    |               0.08 | [ 0.04, 0.12]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p><code>standardize_parameters</code> also has a <code>robust</code> argument (default to <code>FALSE</code>), which enables a <strong>robust standardization of the data</strong>, <em>i.e.</em>, based on the <strong>median</strong> and <strong>MAD</strong> instead of the <strong>mean</strong> and <strong>SD</strong>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>, <span class="dt">robust =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |         95% CI
&gt; --------------------------------------------------
&gt; (Intercept)  |              -0.20 | [-0.27, -0.13]
&gt; xtra_hours   |               0.65 | [ 0.62,  0.68]
&gt; n_comps      |               0.82 | [ 0.74,  0.89]
&gt; age_g(30,35] |               0.07 | [-0.01,  0.16]
&gt; age_g(35,45] |               0.11 | [-0.05,  0.27]
&gt; seniority    |               0.12 | [ 0.07,  0.18]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p>Note that since <code>age_g</code> is a factor, it is not numerically standardized, and so it standardized parameter is still not directly comparable to those of numeric variables. To address this, we can set <code>two_sd = TRUE</code>, thereby scaling parameters on 2 SDs (or MADs) of the predictors (Gelman 2008).</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>, <span class="dt">two_sd =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |              -0.05 | [-0.11, 0.02]
&gt; xtra_hours   |               1.54 | [ 1.46, 1.61]
&gt; n_comps      |               0.78 | [ 0.72, 0.85]
&gt; age_g(30,35] |               0.06 | [-0.01, 0.14]
&gt; age_g(35,45] |               0.10 | [-0.04, 0.23]
&gt; seniority    |               0.16 | [ 0.09, 0.24]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<p><code>effectsize</code> also comes with a helper function that returns the re-fit model, without summarizing it, which can then be used as the original model would:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a>mod_z &lt;-<span class="st"> </span><span class="kw">standardize</span>(mod, <span class="dt">two_sd =</span> <span class="ot">FALSE</span>, <span class="dt">robust =</span> <span class="ot">FALSE</span>)</span>
<span id="cb35-2"><a href="#cb35-2"></a>mod_z</span></code></pre></div>
<pre><code>&gt; 
&gt; Call:
&gt; lm(formula = salary ~ xtra_hours + n_comps + age_g + seniority, 
&gt;     data = data_std)
&gt; 
&gt; Coefficients:
&gt;  (Intercept)    xtra_hours       n_comps  age_g(30,35]  age_g(35,45]  
&gt;      -0.0458        0.7692        0.3921        0.0635        0.0962  
&gt;    seniority  
&gt;       0.0821
</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">model_parameters</span>(mod_z)</span></code></pre></div>
<pre><code>&gt; Parameter       | Coefficient |   SE |        95% CI | t(494) |      p
&gt; ----------------------------------------------------------------------
&gt; (Intercept)     |       -0.05 | 0.03 | [-0.11, 0.02] |  -1.47 | 0.142 
&gt; xtra_hours      |        0.77 | 0.02 | [ 0.73, 0.81] |  39.76 | &lt; .001
&gt; n_comps         |        0.39 | 0.02 | [ 0.36, 0.43] |  22.46 | &lt; .001
&gt; age_g [(30,35]] |        0.06 | 0.04 | [-0.01, 0.14] |   1.63 | 0.103 
&gt; age_g [(35,45]] |        0.10 | 0.07 | [-0.04, 0.23] |   1.39 | 0.164 
&gt; seniority       |        0.08 | 0.02 | [ 0.04, 0.12] |   4.34 | &lt; .001
</code></pre>
<h3 id="posthoc-refit-without-refitting"><strong><code>&quot;posthoc&quot;</code></strong>: Refit without refitting</h3>
<p>Post-hoc standardization of the parameters aims at emulating the results obtained by <code>&quot;refit&quot;</code> without refitting the model. The coefficients are divided by the standard deviation (or MAD if <code>robust</code>) of the outcome (which becomes their expression ‘unit’). Then, the coefficients related to numeric variables are additionally multiplied by the standard deviation (or MAD if <code>robust</code>) of the related terms, so that they correspond to changes of 1 SD of the predictor (e.g., &quot;A change in 1 SD of <em>x</em> is related to a change of 0.24 of the SD of <em>y</em>). This does not apply to binary variables or factors, so the coefficients are still related to changes in levels. This method is not accurate and tend to give aberrant results when interactions are specified.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;posthoc&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |               0.00 | [ 0.00, 0.00]
&gt; xtra_hours   |               0.77 | [ 0.73, 0.81]
&gt; n_comps      |               0.39 | [ 0.36, 0.43]
&gt; age_g(30,35] |               0.06 | [-0.01, 0.14]
&gt; age_g(35,45] |               0.10 | [-0.04, 0.23]
&gt; seniority    |               0.08 | [ 0.04, 0.12]
&gt; 
&gt; # Standardization method: Posthoc
</code></pre>
<h3 id="smart-standardization-of-models-parameters-with-adjustment-reconnaissance-and-transformation"><strong><code>&quot;smart&quot;</code></strong>: Standardization of Model’s parameters with Adjustment, Reconnaissance and Transformation</h3>
<blockquote>
<p>Experimental</p>
</blockquote>
<p>Similar to <code>method = &quot;posthoc&quot;</code> in that it does not involve model refitting. The difference is that the SD of the response is computed on the relevant section of the data. For instance, if a factor with 3 levels A (the intercept), B and C is entered as a predictor, the effect corresponding to B vs. A will be scaled by the variance of the response at the intercept only. As a results, the coefficients for effects of factors are similar to a Glass’ <em>delta</em>.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;smart&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |               0.00 | [ 0.00, 0.00]
&gt; xtra_hours   |               0.77 | [ 0.73, 0.81]
&gt; n_comps      |               0.39 | [ 0.36, 0.43]
&gt; age_g(30,35] |               0.06 | [-0.01, 0.14]
&gt; age_g(35,45] |               0.10 | [-0.04, 0.23]
&gt; seniority    |               0.08 | [ 0.04, 0.12]
&gt; 
&gt; # Standardization method: Smart
</code></pre>
<h3 id="basic-raw-scaling-of-the-model-frame"><strong><code>&quot;basic&quot;</code></strong>: Raw scaling of the model frame</h3>
<p>This method is similar to <code>method = &quot;posthoc&quot;</code>, but treats all variables as continuous: it scales the coefficient by the standard deviation of model’s matrix’ parameter of factors levels (transformed to integers) or binary predictors. Although it can be argued that this might be inappropriate for these cases, this method allows for easier importance judgment across all predictor type (numeric, factor, interactions…). It is also the type of standardization implemented by default in other software packages (also <code>lm.beta::lm.beta()</code>), and, such as can be used for reproducibility and replication purposes.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">standardize_parameters</span>(mod, <span class="dt">method =</span> <span class="st">&quot;basic&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |        95% CI
&gt; -------------------------------------------------
&gt; (Intercept)  |               0.00 | [ 0.00, 0.00]
&gt; xtra_hours   |               0.77 | [ 0.73, 0.81]
&gt; n_comps      |               0.39 | [ 0.36, 0.43]
&gt; age_g(30,35] |               0.03 | [-0.01, 0.07]
&gt; age_g(35,45] |               0.03 | [-0.01, 0.06]
&gt; seniority    |               0.08 | [ 0.04, 0.12]
&gt; 
&gt; # Standardization method: Basic
</code></pre>
<h2 id="standardizing-parameters-in-mixed-models">Standardizing Parameters In Mixed Models</h2>
<p>Linear mixed models (LMM/HLM/MLM) offer an additional conundrum to standardization - how does one even calculate the SDs of the various predictors? Of of the response - is it the deviations within each group? Or perhaps between them?</p>
<p>The solution: standardize according to level of the predictor (Hoffman 2015, 342)! Level 1 parameters are standardized according to variance <em>withing</em> groups, while level 2 parameters are standardized according to variance <em>between</em> groups. The resulting standardized coefficient are also called <em>pseudo</em>-standardized coefficients.[^Note that like method <code>&quot;basic&quot;</code>, these are based on the model matrix.]</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">library</span>(lme4)</span>
<span id="cb45-2"><a href="#cb45-2"></a>m &lt;-<span class="st"> </span><span class="kw">lmer</span>(mpg <span class="op">~</span><span class="st"> </span>cyl <span class="op">+</span><span class="st"> </span>am <span class="op">+</span><span class="st"> </span>vs <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span><span class="op">|</span>cyl), mtcars)</span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">standardize_parameters</span>(m, <span class="dt">method =</span> <span class="st">&quot;pseudo&quot;</span>, <span class="dt">df_method =</span> <span class="st">&quot;satterthwaite&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter   | Coefficient (std.) |         95% CI
&gt; -------------------------------------------------
&gt; (Intercept) |               0.00 | [ 0.00,  0.00]
&gt; cyl         |              -0.74 | [-1.23, -0.26]
&gt; amAutomatic |               0.47 | [ 0.01,  0.93]
&gt; vs          |               0.20 | [-0.47,  0.87]
&gt; 
&gt; # Standardization method: Pseudo
</code></pre>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># compare to:</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">standardize_parameters</span>(m, <span class="dt">method =</span> <span class="st">&quot;basic&quot;</span>, <span class="dt">df_method =</span> <span class="st">&quot;satterthwaite&quot;</span>)</span></code></pre></div>
<pre><code>&gt; Parameter   | Coefficient (std.) |         95% CI
&gt; -------------------------------------------------
&gt; (Intercept) |               0.00 | [ 0.00,  0.00]
&gt; cyl         |              -0.63 | [-1.05, -0.22]
&gt; amAutomatic |               0.25 | [ 0.00,  0.50]
&gt; vs          |               0.11 | [-0.25,  0.47]
&gt; 
&gt; # Standardization method: Basic
</code></pre>
<h2 id="standardizing-parameters-in-generalized-linear-models">Standardizing Parameters In Generalized Linear Models</h2>
<p>Unlike linear (/mixed) models, in generalized linear (/mixed) models (GLMs) there is <em>less</em> of a need for standardization. Why? Because in many GLMs the estimated coefficients are themselves measures of effect size, such as <em>odds-ratios</em> (OR) in logistic regression, or <em>incidence rate ratios</em> (IRR) in Poisson regressions. This is because in such model the outcome is <strong>not</strong> on an arbitrary scale - that is, the meaning of rates and probabilities are changed by arbitrary linear transformations.</p>
<p>But still, some standardization is sometimes needed, for the predictors. Luckily, <code>standardize_parameters()</code> (and <code>standardize()</code>) are smart enough to know when GLMs are passed so as to only standardize according to the predictors:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a>mod_b &lt;-<span class="st"> </span><span class="kw">glm</span>(am <span class="op">~</span><span class="st"> </span>mpg <span class="op">+</span><span class="st"> </span><span class="kw">factor</span>(cyl),</span>
<span id="cb49-2"><a href="#cb49-2"></a>             <span class="dt">data =</span> mtcars,</span>
<span id="cb49-3"><a href="#cb49-3"></a>             <span class="dt">family =</span> <span class="kw">binomial</span>())</span>
<span id="cb49-4"><a href="#cb49-4"></a></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="kw">standardize_parameters</span>(mod_b, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>, <span class="dt">two_sd =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Coefficient (std.) |         95% CI
&gt; --------------------------------------------------
&gt; (Intercept)  |              -0.91 | [-3.32,  1.33]
&gt; mpg          |               4.46 | [ 0.30, 10.54]
&gt; factor(cyl)6 |               0.73 | [-2.04,  3.66]
&gt; factor(cyl)8 |               0.70 | [-3.13,  4.78]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># standardize_parameters(mod_b, method = &quot;posthoc&quot;, two_sd = TRUE)</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="co"># standardize_parameters(mod_b, method = &quot;basic&quot;)</span></span></code></pre></div>
<p>These can then be converted to OR (with <code>exp()</code>) and discussed as the “<em>change in Odds as a function of a change in one SD of x</em>”.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a>std &lt;-<span class="st"> </span><span class="kw">standardize_parameters</span>(mod_b, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>, <span class="dt">two_sd =</span> <span class="ot">TRUE</span>)</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="kw">exp</span>(std<span class="op">$</span>Std_Coefficient)</span></code></pre></div>
<pre><code>&gt; [1]  0.4 86.4  2.1  2.0
</code></pre>
<p>Or we can directly ask for the coefficients to be exponentiated:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">standardize_parameters</span>(mod_b, <span class="dt">method =</span> <span class="st">&quot;refit&quot;</span>, <span class="dt">two_sd =</span> <span class="ot">TRUE</span>, <span class="dt">exponentiate =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>&gt; Parameter    | Odds Ratio (std.) |           95% CI
&gt; ---------------------------------------------------
&gt; (Intercept)  |              0.40 | [0.04,     3.76]
&gt; mpg          |             86.40 | [1.36, 37955.41]
&gt; factor(cyl)6 |              2.08 | [0.13,    39.04]
&gt; factor(cyl)8 |              2.02 | [0.04,   119.12]
&gt; 
&gt; # Standardization method: Refit
</code></pre>
<h1 id="cohens-f">Cohen’s <em>f</em></h1>
<p>Cohen’s (f) (of <a href="https://easystats.github.io/effectsize/articles/anovaES.html">ANOVA fame</a>) can be used as a measure of effect size in the context of sequential multiple regression. That is, when comparing two models, we can examine the ratio between the increase in (R^2) and the unexplained variance:</p>
<p>[ f^{2}={R_{AB}^{2}-R_{A}^{2} \over 1-R_{AB}^{2}} ]</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a>m1 &lt;-<span class="st"> </span><span class="kw">lm</span>(salary <span class="op">~</span><span class="st"> </span>xtra_hours, <span class="dt">data =</span> hardlyworking)</span>
<span id="cb56-2"><a href="#cb56-2"></a>m2 &lt;-<span class="st"> </span><span class="kw">lm</span>(salary <span class="op">~</span><span class="st"> </span>xtra_hours <span class="op">+</span><span class="st"> </span>n_comps <span class="op">+</span><span class="st"> </span>seniority, <span class="dt">data =</span> hardlyworking)</span>
<span id="cb56-3"><a href="#cb56-3"></a></span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="kw">cohens_f_squared</span>(m1, <span class="dt">model2 =</span> m2)</span></code></pre></div>
<pre><code>&gt; Cohen&#39;s f2 (partial) |       90% CI | R2_delta
&gt; ----------------------------------------------
&gt;                 1.19 | [0.99, 1.40] |     0.17
</code></pre>
<!-- ## Methods Comparison -->

<!-- We will use the "refit" method as the baseline. We will then compute the differences between these standardized parameters and the ones provided by the other functions. The **bigger the (absolute) number, the worse it is**. -->

<!-- > **SPOILER ALERT: the standardization implemented in `effectsize` is the most accurate and the most flexible.** -->

<!-- ### Convenience function -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- library(effectsize) -->

<!-- library(lm.beta) -->

<!-- library(MuMIn) -->

<!-- comparison <- function(model, robust=FALSE){ -->

<!--   out <- standardize_parameters(model, method="refit", robust=robust)[1:2] -->

<!--   out$posthoc <- tryCatch({ -->

<!--     out[, 2] - standardize_parameters(model, method="posthoc", robust=robust)[, 2] -->

<!-- }, error = function(error_condition) { -->

<!--     "Error" -->

<!-- }) -->

<!--   out$basic <- tryCatch({ -->

<!--     out[, 2] - standardize_parameters(model, method="basic", robust=robust)[, 2] -->

<!-- }, error = function(error_condition) { -->

<!--     "Error" -->

<!-- }) -->

<!--   out$lm.beta <- tryCatch({ -->

<!--     out[, 2] - lm.beta::lm.beta(model)$standardized.coefficients -->

<!-- }, error = function(error_condition) { -->

<!--     "Error" -->

<!-- }, warning = function(warning_condition) { -->

<!--   "Error" -->

<!-- }) -->

<!--   out$MuMIn <- tryCatch({ -->

<!--     out[, 2] - MuMIn::std.coef(model, partial.sd=FALSE)[, 1] -->

<!-- }, error = function(error_condition) { -->

<!--     "Error" -->

<!-- }) -->

<!-- ### Data -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- data <- iris -->

<!-- data$Group_Sepal.Width <- as.factor(ifelse(data$Sepal.Width > 3, "High", "Low")) -->

<!-- data$Binary_Sepal.Width <- as.factor(ifelse(data$Sepal.Width > 3, 1, 0)) -->

<!-- summary(data) -->

<!-- ``` -->

<!-- ### Models with only numeric predictors -->

<!-- HERE -->

<!-- #### Linear Model -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Petal.Width + Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Linear Mixed Model -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- library(lme4) -->

<!-- model <- lme4::lmer(Sepal.Length ~ Petal.Width + Sepal.Width + (1|Species), -->

<!--                     data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Bayesian Models -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- library(rstanarm) -->

<!-- model <- stan_glm(Sepal.Length ~ Petal.Width + Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- For these simple models, **all methods return results equal to the "refit" method** (although the other packages fail). -->

<!-- #### Transformation -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ poly(Petal.Width, 2) + poly(Sepal.Width, 2), data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- When transformation are involved (e.g., polynomial transformations), **the basic method becomes very unreliable**. -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Petal.Width + Group_Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Logistic Model -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- glm(Binary_Sepal.Width ~ Petal.Width + Species, data=data, family="binomial") -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Linear Mixed Model -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- library(lme4) -->

<!-- model <- lme4::lmer(Sepal.Length ~ Petal.Length + Group_Sepal.Width + (1|Species), data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Bayesian Models -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- library(rstanarm) -->

<!-- model <- stan_lmer(Sepal.Length ~ Petal.Width + Group_Sepal.Width + (1|Species), -->

<!--                    data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- When factors are involved, the basic method (that standardizes the numeric transformation of factors) give again different results. -->

<!-- HERE -->

<!-- ### Models with interactions -->

<!-- Long story short, coeffcient obtained via **posthoc** standardization (without refitting the model) go berserk when interactions are involved. However, **this is "normal"**: a regression model estimates coefficient between two variables when the other predictors are at 0 (are *fixed* at 0, that people interpret as *"adjusted for"*). When a standardized data is passed (in the *refit* method), the effects and interactions are estimated at the **means** of the other predictors (because 0 is the mean for a standardized variable). Whereas in posthoc standardization, this coefficient correspond to something different (because the 0 corresponds to something different in standardzed and non-standardized data). In other words, when it comes to interaction, passing standardized data results in a different model, which coefficient have an intrinsically different meaning from unstandardized data. And as [for now](https://github.com/easystats/effectsize/issues/6), we are unable to retrieve one from another. -->

<!-- #### Between continuous -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Petal.Width * Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Between factors -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Species * Group_Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- #### Between factors and continuous -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Petal.Width * Group_Sepal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- ```{r message=FALSE, warning=FALSE} -->

<!-- model <- lm(Sepal.Length ~ Group_Sepal.Width * Petal.Width, data=data) -->

<!-- comparison(model) -->

<!-- ``` -->

<!-- ## Conclusion -->

<!-- Use `refit` if possible, but if no interactions, can use `posthoc` or `smart`. -->

<h1 id="references">References</h1>
<div id="refs" class="references hanging-indent">

<div id="ref-gelman2008scaling">

<p>Gelman, Andrew. 2008. “Scaling Regression Inputs by Dividing by Two Standard Deviations.” <em>Statistics in Medicine</em> 27 (15): 2865–73.</p>
</div>

<div id="ref-hoffman2015longitudinal">

<p>Hoffman, Lesa. 2015. <em>Longitudinal Analysis: Modeling Within-Person Fluctuation and Change</em>. Routledge.</p>
</div>

<div id="ref-neter1989applied">

<p>Neter, John, William Wasserman, and Michael H Kutner. 1989. “Applied Linear Regression Models.”</p>
</div>

</div>

</body>
</html>
